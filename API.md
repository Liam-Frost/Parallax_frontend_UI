# Parallax API

This document describes the HTTP API used by the Parallax front-end for authentication and vehicle management.

The API is intentionally minimal and implemented using a pure Java `HttpServer` with in-memory repositories. SQLite integration will be plugged in later behind the same interfaces.

---

## 1. Base URL & Configuration

The front-end reads the base URL from `config.js`:

```js
window.APP_CONFIG = {
  API_BASE: "http://localhost:8080/api"
};
```

All endpoints documented below are relative to `API_BASE`.

For example, a `POST /auth/login` request from the browser goes to:
```
http://localhost:8080/api/auth/login
```

---

## 2. Health

### GET /health

Simple liveness endpoint for monitoring and local testing.

**Response**

- `200 OK` – server is up.
- The body may be a small JSON object or plain text depending on the implementation.

Use this endpoint to check that the backend is running before exercising other APIs.

---

## 3. Authentication

### 3.1 Login

**POST /auth/login**

Used by the sign-in form. Session is still managed client-side (`localStorage`), so the backend only validates credentials and returns a summary of the user.

**Request body (JSON)**

```json
{
  "identifier": "user@example.com or phone number",
  "password": "PlainTextPassword"
}
```

`identifier` may be:
- the account email address, or
- the stored username, or
- a phone number (digits only or country code + digits), depending on how the repository is implemented.

`password` is the user's current password.

**Successful response**

```
200 OK
Content-Type: application/json
```

```json
{
  "success": true,
  "message": "OK",
  "username": "user@example.com",
  "displayName": "First Last"
}
```

The front-end stores `username` in `localStorage.ft_session` and uses it to associate vehicles with the current user.

**Error responses (examples)**

- `400 Bad Request` - Invalid JSON or missing required fields.
- `401 Unauthorized`

```json
{
  "success": false,
  "message": "INVALID_CREDENTIALS"
}
```

### 3.2 Register

**POST /auth/register**

Creates a new user account. For now, users are stored in an in-memory `UserRepository`; later this will be replaced with SQLite.

**Request body (JSON)**

```json
{
  "email": "user@example.com",
  "password": "PlainTextPassword",
  "firstName": "First",
  "lastName": "Last",
  "country": "CA",
  "birthMonth": "05",
  "birthDay": "12",
  "birthYear": "1999",
  "phoneCountry": "+1",
  "phone": "6041234567",
  "contactMethod": "text"
}
```

**Notes:**
- `email` will also be used as username.
- `phoneCountry` is a dial code such as `+1`, `+86`, etc.
- `phone` should contain only digits (the front-end already strips non-digits).

**Successful response**

```
201 Created
Content-Type: application/json
```

```json
{
  "success": true,
  "message": "CREATED"
}
```

The front-end then:
- Keeps its own local representation of the user for legacy flows, and
- Immediately transitions to the My Vehicles page.

**Error responses**

- `409 Conflict`

```json
{
  "success": false,
  "message": "EMAIL_EXISTS"
}
```

Occurs when a user with the same email is already registered.

Other validation failures may be returned as `400 Bad Request` with an appropriate message code.

---

## 4. Vehicles

All vehicle APIs associate records with a username (the email).

### 4.1 List vehicles

**GET /vehicles**

Returns all vehicles registered by a specific user.

**Query parameters**

- `username` (required) – the account identifier, typically the email.

**Example:**

```
GET /api/vehicles?username=user@example.com
```

**Successful response**

```
200 OK
Content-Type: application/json
```

```json
[
  {
    "username": "user@example.com",
    "licenseNumber": "ABC1234",
    "make": "Toyota",
    "model": "Corolla",
    "year": "2020",
    "blacklisted": false,
    "createdAt": "2025-11-26T19:30:12Z"
  }
]
```

If the user has no vehicles, an empty array `[]` is returned.

**Possible errors**

- `400 Bad Request` - Missing username parameter.
- `500 Internal Server Error` - Unexpected server-side failure.

### 4.2 Add a vehicle

**POST /vehicles**

Registers a new vehicle for the current user.

**Request body (JSON)**

```json
{
  "username": "user@example.com",
  "licenseNumber": "ABC1234",
  "make": "Toyota",
  "model": "Corolla",
  "year": "2020"
}
```

**Notes:**
- `licenseNumber` must be 1–7 chars, using A–Z, digits, or `-`.
- The front-end validates this before sending.
- `blacklisted` is implicitly set to `false` on creation.
- `createdAt` is generated by the server.

**Successful response**

```
201 Created
Content-Type: application/json
```

```json
{
  "username": "user@example.com",
  "licenseNumber": "ABC1234",
  "make": "Toyota",
  "model": "Corolla",
  "year": "2020",
  "blacklisted": false,
  "createdAt": "2025-11-26T19:30:12Z"
}
```

The front-end refreshes the table using `GET /vehicles` afterwards.

**Error responses**

- `409 Conflict`

```json
{
  "message": "LICENSE_EXISTS"
}
```

A vehicle with the same `licenseNumber` already exists for this user.

- `400 Bad Request` - Missing or invalid input fields.

### 4.3 Remove a vehicle

**DELETE /vehicles**

Deletes a specific vehicle owned by the user.

**Request body (JSON)**

```json
{
  "username": "user@example.com",
  "licenseNumber": "ABC1234"
}
```

**Successful response**

```
204 No Content
```

No body is returned.

The front-end then re-fetches the list with `GET /vehicles`.

**Error responses**

- `404 Not Found`

```json
{
  "message": "NOT_FOUND"
}
```

No matching vehicle for this username and license number.

- `400 Bad Request` - Invalid or missing fields.

---

## 5. Data Models (Summary)

### User

```java
class User {
  String username;      // same as email
  String email;
  String password;      // plain text for demo only (will be hashed later)
  String firstName;
  String lastName;
  String country;
  String birthMonth;
  String birthDay;
  String birthYear;
  String phoneCountry;
  String phone;
  String contactMethod;
}
```

### Vehicle

```java
class Vehicle {
  String username;
  String licenseNumber;
  String make;
  String model;
  String year;
  boolean blacklisted;
  String createdAt;
}
```

---

## 6. Notes for Future SQLite Integration

- `UserRepository` and `VehicleRepository` currently use in-memory collections (`ConcurrentHashMap`, `List`, etc.).
- Each method is structured so it can be replaced by an SQL query without changing the HTTP handlers.

When SQLite is introduced:
- Keep the same method signatures.
- Replace in-memory lookups with `SELECT` / `INSERT` / `DELETE` statements.
- Ensure unique constraints on `users.email` and `(vehicles.username, vehicles.licenseNumber)`.